import pandas as pd

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

from prophet import Prophet
import ruptures as rpt
from ruptures.utils import pairwise
from itertools import cycle

mpl.rcParams['figure.figsize'] = (20, 16)
mpl.rcParams['axes.grid'] = False




class AnomalyDetector:
    def __init__(self,df, test_window=14, train_window=21, beta=0.1, 
    ruptures_changepnt_penalty=10, prophet_interval_width=0.95, 
    prophet_changepnt_prior = 0.15, weekly_seasonality= False,
    color_cycle = ["#4286f4", "#f44174"]):
        '''
        Args
        ---
        changepoint_penalty: float
        Higher the value, more conservative the segmentation, must be >0
        '''
        self.df = df
        self.test_window = test_window
        self.train_window = train_window
        self.beta = beta
        self.ruptures_changepnt_penalty = ruptures_changepnt_penalty
        self.prophet_interval_width = prophet_interval_width
        self.prophet_changepnt_prior = prophet_changepnt_prior
        self.weekly_seasonality = weekly_seasonality
        self.color_cycle = color_cycle
        # self.P = P


    def apply_changepnt_detection(self,changepnt_model="rbf"):
            
        '''
        Apply changepoint detection ala ruptures package and generate breakpoint indices
        Args
        ---
        changepoint_model: str
            Pelt segment model, ["l1", "l2", "rbf"] 
            https://centre-borelli.github.io/ruptures-docs/code-reference/detection/pelt-reference/

        
        Returns
        ---
        breakpoints: list
            List of breakpoint indices
        '''
        signal = self.df['y'].to_numpy()
        algo = rpt.Pelt(model=changepnt_model).fit(signal)
        result = algo.predict(pen=self.ruptures_changepnt_penalty)
        breakpoints = [0] + sorted(result)
        self.changepnts = breakpoints
        return self

    def plot_changepoints(self): 
        color_cycle = cycle(self.color_cycle)
        fig, ax = plt.subplots(1,1,figsize=(16,8))
        ax.plot(self.df['ds'],self.df['y'], '-o', markersize=2, linewidth=1)
        for (start, end), col in zip(pairwise(self.changepnts), color_cycle):
            ax.axvspan(self.df.iloc[max(0,start-1)]['ds'], self.df.iloc[end-1]['ds'], facecolor=col,alpha=0.2)
        plt.show()

    def prophet_fit(self):

        #instantiate the prophet model
        prophet_model = Prophet(interval_width=self.prophet_interval_width,
            yearly_seasonality=False,
            weekly_seasonality=self.weekly_seasonality,
            changepoint_prior_scale=self.prophet_changepnt_prior
            )
        
        #segment time frames
        # Test/Forecast window
        end_index = self.df.index[-1]
        test_start_index = end_index - self.test_window + 1 
        print(f'TEST start index is {test_start_index}')
        print(f'TEST END index is {end_index}') #the test end index is setup to be the last index of df
        
        # Train window, starts at the last changepoint unless the train window goes further back
        if test_start_index - self.changepnts[-2] < self.train_window:
            train_start_index = test_start_index - self.train_window
        else:
            train_start_index = self.changepnts[-2]
        print(f'TRAIN start index is {train_start_index}')

        train_end_index = test_start_index - 1
        print(f'TRAIN end index is {train_end_index}')
        baseline_ts = self.df['ds'][train_start_index:train_end_index]
        baseline_y = self.df['y'][train_start_index:train_end_index]
        print('TRAIN from {} to {}'.format(self.df['ds'][train_start_index], self.df['ds'][train_end_index]))
        print('PREDICT from {} to {}'.format(self.df['ds'][test_start_index], self.df['ds'][end_index]))

        # fit the model
        prophet_model.fit(pd.DataFrame({'ds': baseline_ts.values,
                                        'y': baseline_y.values}))#,  algorithm = 'Newton')
        
        future = prophet_model.make_future_dataframe(periods=self.test_window)
        # make prediction
        forecast = prophet_model.predict(future)
        self.forecast = forecast
        self.model = prophet_model
        return self

    def get_outliers(self):
        """
        Combine the actual values and forecast in a data frame and identify the outliers
        Args
        ----
        df : pandas DataFrame
            The daily time-series data set contains ds column for
            dates (datetime types such as datetime64[ns]) and y column for numerical values
        forecast : pandas DataFrame
            The predicted result in a dataframe which was previously generated by
            Prophet's model.predict(future)
        beta : float
            amplifying factor for setting lower and upperbounds for anomalies
        test_window : int
            Number of days for Prophet to make predictions for
        Returns
        -------
        outliers : a list of (datetime, int, int) triple
            A list of outliers, the date, the value, and penalty for each
        df_pred : pandas DataFrame
            The data set contains actual and predictions for the forecast time frame
        P : int
            Net penalty value of all the outliers detected
        """
        df_pred = self.forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(self.test_window)
        df_pred.index = df_pred['ds'].dt.to_pydatetime()
        df_pred.columns = ['ds', 'preds', 'lower_y', 'upper_y']
        end_index = self.df.index[-1]

        test_start_index = end_index - self.test_window 
        df_pred['actual'] = self.df['y'][test_start_index: end_index].values

        # construct a list of outliers
        outlier_index = list()
        outliers = list()
        penalty = list()
        P = 0 # net penalty
        for i in range(df_pred.shape[0]):
            actual_value = df_pred['actual'][i]
            pred_value   = df_pred['preds'][i]
            lower_bound  = (1-self.beta)*df_pred['lower_y'][i]
            upper_bound  = (1+self.beta)*df_pred['upper_y'][i]
            if actual_value < lower_bound:
                outlier_index += [i]
                p = (pred_value - actual_value)/pred_value
                penalty.append(p)
                outliers.append((df_pred.index[i], actual_value, p))
                
            elif actual_value > upper_bound:
                outlier_index += [i]
                p = (actual_value - pred_value)/pred_value
                penalty.append(p)
                outliers.append((df_pred.index[i], actual_value, p))            

                # print out the evaluation for each outlier
                print('=====')
                print('actual value {} fall outside of the prediction interval'.format(actual_value))
                print('interval: {} to {}'.format(lower_bound, upper_bound))
                print('Date: {}'.format(str(df_pred.index[i])[:10]))

        P = sum(penalty)
        print('Net Penalty for the prediction interval of last {} days is {}'.format(self.test_window, P))
        for outlier in outliers:
            print(outlier)
        
        self.outliers = outliers #list
        self.P = P  #scalar

        return self



    def prophet_plot(self):#df, forecast, prophet_model, changepoints_list, outliers=list()):
        """
        Plot the actual, predictions, and anomalous values
        Args
        ----
        df : pandas DataFrame
            The daily time-series data set contains ds column for
            dates (datetime types such as datetime64[ns]) and y column for numerical values

        outliers : a list of (datetime, int) tuple
            The outliers we want to highlight on the plot.
        """
        # generate the plot
        fig = self.model.plot(self.forecast)
        
        # retrieve the subplot in the generated Prophets matplotlib figure
        ax = fig.get_axes()[0]

        #plot actual values
        x_pydatetime = self.df['ds'].dt.to_pydatetime()
        ax.plot(x_pydatetime,
            self.df.y,
            color='orange', label='Actual')

        # plot each outlier in red, uncomment the second line to annotate date (makes it super crowded though)
        for outlier in self.outliers:
            ax.scatter(outlier[0], outlier[1], s = 16, marker='x', color='red', label='Anomaly')
            # ax.text(outlier[0], outlier[1], str(outlier[0])[:10], color='red')


        # re-organize the legend
        patch1 = mpatches.Patch(color='red', label='Anomaly')
        patch2 = mpatches.Patch(color='orange', label='Actual')
        patch3 = mpatches.Patch(color='skyblue', label='Prediction interval')
        plt.legend(handles=[patch1, 
                            patch2, 
                            patch3, 
                            ])
        
        #plot the changepoints

        color_cycle = cycle(self.color_cycle)
        for (start, end), col in zip(pairwise(self.changepnts), color_cycle):
            ax.axvspan(self.df.iloc[max(0,start-1)]['ds'], self.df.iloc[end-1]['ds'], facecolor=col,alpha=0.2)

        plt.show()
